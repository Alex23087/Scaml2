\documentclass[a4paper, 12pt]{article}
\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, width=15.09cm]{geometry}

\usepackage{mlmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{mathtools,stmaryrd,galois,amsmath,amssymb,amsthm,prftree}
\usepackage{graphicx,tikz,quiver}
\usepackage{mleftright,xspace}

\usepackage{listings,lstautogobble}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  autogobble=true,
  xleftmargin=2em,
  literate={lam.}{{$\lambda$}}1,
  showstringspaces=false,
}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\renewcommand*{\O}[1]{\mathrm{O}(#1)}
\newcommand*{\wdeg}[1]{\operatorname{wdeg}{#1}}

\newcommand*{\abs}[1]{\left| #1 \right|}
\newcommand*{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand*{\floor}[1]{\left\lfloor #1 \right\rfloor}

\newcommand*{\pr}[1]{\mathrm{P}\!\left( #1 \right)}

\newcommand*{\lam}[2]{\lambda #1.\;#2}
\newcommand*{\ext}[3]{#1[#2 \mapsto #3]}

\DeclareMathOperator{\subtype}{\scalebox{0.6}[1]{$<$}\hspace{-0.75pt}\raisebox{0.25pt}{:}}
\DeclareMathOperator{\nsubtype}{\scalebox{0.8}{$\not$}\hspace{-0.2pt}\scalebox{0.6}[1]{$<$}\hspace{-0.75pt}\raisebox{0.25pt}{:}}
\DeclareMathOperator{\supertype}{\reflectbox{$\subtype$}}
\DeclareMathOperator{\nsupertype}{\reflectbox{$\nsubtype$}}

\newcommand*{\Fsub}{\ensuremath{F_{\subtype}}}
\newcommand*{\lambdasub}{\ensuremath{\lambda_{\subtype}}}

\DeclareMathOperator{\domin}{\geq\hspace{-3.5pt}\geq}

\newcommand*{\dom}[1]{\operatorname{dom}\!\left( #1 \right)}
\newcommand*{\cod}[1]{\operatorname{cod}\!\left( #1 \right)}
\newcommand*{\id}{\mathrm{id}}
\newcommand*{\op}{^{\mathrm{op}}}
\newcommand*{\inv}{^{-1}}

\newenvironment{grammar}
  {\newcommand*{\is}{&::=&}
   \newcommand*{\alt}{\;\mid\;}
   \newcommand*{\altnl}{\\&\mid&}
   \newcommand*{\isin}{&\in&}
   \[\begin{array}{rrll}}
  {\end{array}\]}

\newcommand*{\bste}[4]{#1, #2 \vdash #3 \Downarrow #4}
\newcommand*{\bstep}[5]{#1, #2 \vdash #3 \Downarrow \langle #4,\; #5\rangle}
\newcommand*{\bstepp}[6]{#1, #2 \vdash #3 \Downarrow \langle #4,\; \langle  #5,\; #6\rangle \rangle}

\newcommand*{\diverges}[2]{\langle #1, #2 \rangle \Uparrow}
\newcommand*{\slam}[2]{\lambda #1.\;#2}
\newcommand*{\slet}[4]{\texttt{let}~#1~#2 = #3~\texttt{in}~#4}
\newcommand*{\sletrec}[4]{\texttt{let rec}~#1~#2 = #3~\texttt{in}~#4}
\newcommand*{\sletrecand}[5]{\texttt{let rec}~#1~#2 = #3~\texttt{and}~#4~\texttt{in}~#5}
\newcommand*{\sseq}{\texttt{;}}
\newcommand*{\sif}[3]{\texttt{if}~#1~\texttt{then}~#2~\texttt{else}~#3}
\newcommand*{\sfix}[1]{\texttt{fix}~#1}
\newcommand*{\sfixs}[1]{\texttt{fix*}~#1}
\newcommand*{\shandle}[2]{\texttt{with}~#1~\texttt{handle}~#2}
\newcommand*{\sdo}[2]{\texttt{do}~#1~#2}
\newcommand*{\smodule}[1]{\texttt{module}~#1~\texttt{end}}
\newcommand*{\strusted}[1]{\texttt{trusted module}~#1~\texttt{end}}
\newcommand*{\splugin}[2]{\texttt{plugin}~#1~#2~\texttt{end}}
\newcommand*{\stint}{\texttt{int}}
\newcommand*{\ststring}{\texttt{string}}
\newcommand*{\stbool}{\texttt{bool}}
\newcommand*{\stany}{\texttt{any}}
\newcommand*{\stfun}[2]{#1~\texttt{->}~#2}
\newcommand*{\sdlet}[3]{\texttt{let}~#1~#2 = #3}
\newcommand*{\sdletand}[4]{\texttt{let}~#1~#2 = #3~\texttt{and}~#4}
\newcommand*{\sdletrec}[3]{\texttt{let rec}~#1~#2 = #3}
\newcommand*{\sexport}[1]{\texttt{export}~#1}
\newcommand*{\stuple}[1]{\texttt{[}#1\texttt{]}}
\newcommand*{\scomma}{\texttt{,}}
\newcommand*{\sproj}[2]{#1\texttt{[} #2 \texttt{]}}

\newcommand*{\vmodule}[1]{\text{mod}~#1}
\newcommand*{\vtrusted}[1]{\text{tmod}~#1}
\newcommand*{\vplugin}[1]{\text{plug}~#1}

\newcommand*{\vlam}[3]{\lambda^{#1} #2.\;#3}

\newcommand*{\true}{\mathbf{tt}}
\newcommand*{\false}{\mathbf{ff}}

\newcommand*{\valpair}{\mathbf}

\newcommand*{\sdie}[1]{\texttt{die}}
\newcommand*{\spredicate}[2]{\texttt{has\_attr}~#1~#2}

\newcommand*{\sprint}[1]{\texttt{print}~#1}

\newcommand*{\vdefer}[2]{\mathrm{defer}^{#1}~#2}
\newcommand*{\vprivate}{\mathrm{private}}
\newcommand*{\vexport}{\mathrm{export}}
\newcommand*{\vnosecret}[1]{\mathrm{nosecret}~#1}

\newcommand*{\soptional}[1]{#1{\!\!?}}

\newcommand*{\sdeclassify}[1]{\texttt{declassify}~#1}
\newcommand*{\sendorse}[1]{\texttt{endorse}~#1}

\definecolor{grigio}{rgb}{0.9, 0.9, 0.9}

\title{LBTS project report}
\author{Andrea Simone Costa \and Alessio Duè \and Alessandro Scala}

\begin{document}

\maketitle

\section{Syntax}

\begin{grammar}
  e \is x \alt v \alt e.x \alt \texttt{(} e \texttt{)}
  \altnl e~\mathit{bop}~e \alt \mathit{uop}~e
  \alt \stuple{e \scomma \dots \scomma e} \alt \sproj e e
  \altnl e~e \alt \slam x e \alt \sfix e \alt \sfixs e\alt \mathit{let}
  \altnl \sif e e e
  \altnl \shandle h e \alt \sdo {\mathit{op}} {e*}
  \altnl \smodule {d{*}} \alt \strusted {d{*}} \alt \splugin s {\mathit{intf}{*}}
  \altnl \sdie e \alt \spredicate {\mathit{attr}} e \alt \sdeclassify e \alt \sendorse e
  \altnl \sprint e
  \\
  \\
  \mathit{let} \is \slet {\mathit{attr}{*}} x e e
  \altnl \texttt{let rec}~{\mathit{attr}{*}}~x = e~(\texttt{and}~\mathit{attr}{*}~x = e){*}~\texttt{in}~e
  \\
  \\
  h \is \texttt{\{} (\mathit{op}~x+ = e\texttt{,}){*}~\texttt{return}~x = e \texttt{\}}
  \\
  \mathit{intf} \is x~\texttt{:}~\tau
  \\
  d \is \sdlet {\mathit{attr}{*}} x e
  \altnl \sdletrec {\mathit{attr}{*}} x e~(\texttt{and}~d){*}
  \altnl \sexport x
  \\
  \\
  v \isin \mathrm{Int} \cup \mathrm{Str} \cup \mathrm{Bool}
  % m \is \vmodule {d{*}} \alt \vtrusted {d{*}} \alt \vplugin {i{*}} {d{*}}
  \\
  s \isin \mathrm{Str}
  \\
  x,\mathit{op} \isin \mathrm{Ide}
  \\
  \\
  \mathit{attr} \is \texttt{public} \alt \texttt{secret} \alt \texttt{tainted} \alt \texttt{untainted}
  \\
  \tau \is \stany \alt \stint \alt \ststring \alt \stbool \alt \stfun \tau \tau \alt \stuple{\tau \scomma \dots \scomma \tau} \alt \texttt{(} \tau \texttt{)}
\end{grammar}


The surface syntax has ; let and forse rec boh zucchero per le funzioni let, return non obbligatorio

\section{Operational semantics}

Lbl lattice

% https://q.uiver.app/#q=WzAsNCxbMSw0LCIoXFxtYXRocm17cHVibGljfSwgXFxtYXRocm17dW50YWludGVkfSkiXSxbMiwyLCIoXFxtYXRocm17cHVibGljfSwgXFxtYXRocm17dGFpbnRlZH0pIl0sWzAsMiwiKFxcbWF0aHJte3NlY3JldH0sIFxcbWF0aHJte3VudGFpbnRlZH0pIl0sWzEsMCwiKFxcbWF0aHJte3NlY3JldH0sIFxcbWF0aHJte3RhaW50ZWR9KSJdLFswLDIsIiIsMCx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiwzLCIiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsMSwiIiwyLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxLDMsIiIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
\[\begin{tikzcd}
    & {(\mathrm{secret}, \mathrm{tainted})} \\
    \\
    {(\mathrm{secret}, \mathrm{untainted})} && {(\mathrm{public}, \mathrm{tainted})} \\
    \\
    & {(\mathrm{public}, \mathrm{untainted})}
    \arrow[no head, from=3-1, to=1-2]
    \arrow[no head, from=3-3, to=1-2]
    \arrow[no head, from=5-2, to=3-1]
    \arrow[no head, from=5-2, to=3-3]
  \end{tikzcd}\]

\begin{align*}
  \mathrm{Val} &= \mathrm{BareVal} \times \mathrm{Lbl}
  \\
  \mathrm{NoSecret} &= \left\{ \vnosecret v \mid v \in \mathrm{BareVal} \right\}
  \\
  \mathrm{BareVal} &= \mathrm{Int} \cup \mathrm{Str} \cup \mathrm{Bool} \cup \mathrm{Fun} \cup \mathrm{Val}^* \cup \mathrm{Defer} \cup \mathrm{Mod} \cup \mathrm{ValType} \cup \mathrm{NoSecret}
  \\
  \\
  \mathrm{Int} &= \mathbb N \\
  \mathrm{Str} &= \mathrm{ASCII}^* \\
  \mathrm{Bool} &= \left\{ \true, \false \right\}
  \\
  \\
  \mathrm{Env} &= \mathrm{Val}^{\mathrm{Ide} \,\cup\, \left\{ \mathrm{trusted} \right\}}
  \\
  \mathrm{Fun} &= \left\{ \vlam \Delta x e \mid \Delta \in \mathrm{Env}, x \in \mathrm{Ide}, e \in \mathrm{Exp} \right\}
  \\
  \mathrm{Defer} &= \left\{ \vdefer \Delta e \mid \Delta \in \mathrm{Env}, e \in \mathrm{Exp} \right\}
  \\
  \\
  \mathrm{Mod} &=
                   \left\{\vmodule \Delta \mid \Delta \in \mathrm{Env}\right\}
                   \cup \left\{\vtrusted \Delta \mid \Delta \in \mathrm{Env}\right\}
                   \cup \left\{\vplugin \Delta \mid \Delta \in \mathrm{Env}\right\}
  \\
  \\
  \mathrm{ValType} &= \left\{ v : \tau \mid v \in \mathrm{BareVal}, \tau \in \mathrm{Type} \right\}
\end{align*}
where Exp is the set of syntactic elements generated by the nonterminal \(e\) in the grammar, and Type by the nonterminal \(\tau\).


\[ {\Downarrow} : \mathrm{Env} \times \mathrm{Lbl} \times \mathrm{Exp} \to \mathrm{Val} \cup (\mathrm{Ide} \times \mathrm{Fun} \times \mathrm{Val}^* \times \mathrm{Lbl}) \]

\begin{gather*}
  \prftree[r]{[Val]}{\bstep{\Delta}{pc}{v}{\llbracket v \rrbracket}{pc}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Var]}
  {\Delta(x) = \langle v, \ell \rangle}
  {v \neq \vdefer {\Delta'} e}
  {\bstep{\Delta}{pc}{x}{v}{pc \sqcup \ell}}
  \qquad
  \prftree[r]{[VarDefer]}
  {\Delta(x) = \langle \vdefer {\Delta'} e, \ell_1 \rangle}
  {\bstep{\Delta'}{pc}{e}{v}{\ell_2}}
  {\bstep{\Delta}{pc}{x}{v}{pc \sqcup \ell_1 \sqcup \ell_2}}
  \\[4ex]\displaybreak[1]
  \prftree[r]{[Proj]}
  {\bstep{\Delta}{pc}{e_1}{[ \langle v_j, \ell_{v_{j}} \rangle]_{j \in [0,\dots,n-1]}}{\ell_1}}
  {\bstep{\Delta}{pc}{e_2}{i}{\ell_2}}
  {0 \leq i \leq n-1}
  {v_{i} \neq \vdefer {\Delta'} e}
  {\bstep{\Delta}{pc}{\sproj {e_1} {e_2}}{v_{i}}{pc \sqcup \ell_1 \sqcup \ell_2 \sqcup \ell_{v_i}}}
  \\[1.5ex]\displaybreak[0]
  \prftree[r]{[ProjDefer]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_1}{[ \langle v_j, \ell_{v_{j}} \rangle]_{j \in [0,\dots,n-1]}}{\ell_1}}
    {\bstep{\Delta}{pc}{e_2}{i}{\ell_2} \quad {0 \leq i \leq n-1}}
    {v_{i} = \vdefer {\Delta'} e \quad \bstep{\Delta'}{pc}{e}{v}{\ell_3}}}
  {\bstep{\Delta}{pc}{\sproj {e_1} {e_2}}{v}{pc \sqcup \ell_1 \sqcup \ell_2 \sqcup \ell_{v_i} \sqcup \ell_3}}
  \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Lam]}{\bstep{\Delta}{pc}{\slam x e}{\vlam \Delta x e}{pc}} \\[1.5ex]\displaybreak[0]
  \prftree[r]{[Tuple]}
  {\forall i \in [1,n].\; \bstep{\Delta}{pc}{e_i}{v_i}{\ell_i} \triangleq \valpair v_{i}}
  {\bstep{\Delta}{pc}{\stuple{e_1\scomma \dots\scomma e_{n}}}{[\valpair v_1, \dots, \valpair v_{n}]}{pc \sqcup \bigsqcup_{i = 1}^{n} \ell_{i}}} \\[4ex]\displaybreak[0]
  %
  \prftree[r]{[App]}
  {\bstep{\Delta}{pc}{e_1}{\vlam {\Delta'} x e}{\ell_{f}}}
  {\bste{\Delta}{pc}{e_2}{\valpair v}}
  {\bstep{\ext {\Delta'} x {\valpair v}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}}}
  {\bstep{\Delta}{pc}{e_1~e_2}{u}{pc \sqcup \ell_{f} \sqcup \ell_{u}}} \\[1.5ex]\displaybreak[0]
  %
  % \prftree[r]{[AppNoSecret]}
  % {\bstep{\Delta}{pc}{e_1}{\vnosecret f}{\ell_{f}}}
  % {\bstep{\Delta}{pc}{\valpair f~e_2}{asd}{\ell_{f}}}
  % {\bstep{\Delta}{pc}{e_1~e_2}{\text{apply-nosecret}()}{pc}} \\[1.5ex]\displaybreak[0]
  \prftree[r]{[AppNoSecret]}
  {\prfStackPremises
    {{\bstep{\Delta}{pc}{e_1}{\vnosecret {\vlam {\Delta'} x e}}{\ell_{f}}}
    \quad {\bste{\Delta}{pc}{e_2}{\valpair v}}}
    {\bstep{\ext {\Delta'} x {\valpair v}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}} \triangleq \valpair u}}
  {\bstep{\Delta}{pc}{e_1~e_2}{\text{apply-nosecret}(\valpair u)}{pc \sqcup \ell_{f} \sqcup \ell_{u}}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[AppIntf]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_1}{(\vlam {\Delta'} x e) : \tau_1 \to \tau_2}{\ell_{f}}}
    {\bste{\Delta}{pc}{e_2}{\valpair v}
      \quad \valpair v' \triangleq \text{apply-nosecret}(\valpair v)
      \quad \valpair v'' \triangleq \text{apply-intf}(\valpair v', \tau_1)}
    {\bstep{\ext {\Delta'} x {\valpair v''}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}} \triangleq \valpair u
    \quad \langle u', \ell_{u}' \rangle \triangleq \text{apply-intf}(\valpair u, \tau_2)}}
  {\bstep{\Delta}{pc}{e_1~e_2}{u'}{pc \sqcup \ell_{f} \sqcup \ell_{u}'}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[AppIntfNoSecret]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_1}{\vnosecret {(\vlam {\Delta'} x e) : \tau_1 \to \tau_2}}{\ell_{f}}}
    {\bste{\Delta}{pc}{e_2}{\valpair v}
      \quad \valpair v' \triangleq \text{apply-nosecret}(\valpair v)
      \quad \valpair v'' \triangleq \text{apply-intf}(\valpair v', \tau_1)}
    {\bstep{\ext {\Delta'} x {\valpair v'}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}} \triangleq \valpair u
    \quad \valpair u' \triangleq \langle u', \ell_{u}' \rangle \triangleq \text{apply-intf}(\valpair u, \tau_2)}}
  {\bstep{\Delta}{pc}{e_1~e_2}{\text{apply-nosecret}(\valpair u')}{pc \sqcup \ell_{f} \sqcup \ell_{u}'}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Uop]}
  {\bstep{\Delta}{pc}{e}{v}{\ell}}
  {\bstep{\Delta}{pc}{\mathit{uop}~e}{\llbracket \mathit{uop} \rrbracket(v)}{pc \sqcup \ell}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Bop]}
  {\bstep{\Delta}{pc}{e_1}{v_1}{\ell_1}}
  {\bstep{\Delta}{pc}{e_2}{v_2}{\ell_2}}
  {\bstep{\Delta}{pc}{e_1~\mathit{bop}~e_2}{\llbracket \mathit{bop} \rrbracket(v_1, v_2)}{pc \sqcup \ell_1 \sqcup \ell_2}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[IfTrue]}
  {\bstep{\Delta}{pc}{e_c}{\true}{\ell_{c}}}
  {\bstep{\Delta}{pc \sqcup \ell_{c}}{e_t}{v}{\ell_t}}
  {\bstep{\Delta}{pc}{\sif {e_{c}} {e_{t}} {e_{e}}}{v}{pc \sqcup \ell_c \sqcup \ell_t}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[IfFalse]}
  {\bstep{\Delta}{pc}{e_c}{\false}{\ell_{c}}}
  {\bstep{\Delta}{pc \sqcup \ell_{c}}{e_e}{v}{\ell_e}}
  {\bstep{\Delta}{pc}{\sif {e_{c}} {e_{t}} {e_{e}}}{v}{pc \sqcup \ell_c \sqcup \ell_e}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Fix]}
  {\bstep{\Delta}{pc}{e}{\vlam {\Delta'} x {e'}}{\ell}}
  {\bstep{\ext {\Delta'}{x}{\langle \vdefer {\Delta'} {\sfix {\slam x {e'}}}, \ell \rangle}}{pc \sqcup \ell}{e'}{v}{\ell'}}
  {\bstep{\Delta}{pc}{\sfix e}{v}{pc \sqcup \ell \sqcup \ell'}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Fix*]}
  {\prfStackPremises
    % {\forall i \in [1,n].\; \bste{\Delta}{pc}{e_i}{\overbrace{\langle\vlam {\Delta_i'} {x_{i}} {e_i'},\;{\ell_i}\rangle}^{f_{i}}}}
    {\bstep{\Delta}{pc}{e}{[ \overbrace{\langle\vlam {\Delta_i'} {x_{i}} {e_i'},\;{\ell_i}\rangle}^{f_{i}} ]_{i \in [1,n]}}{\ell}}
    {\Delta'' \triangleq \Delta[y_1 \mapsto f_1,\dots,y_{n} \mapsto f_{n}] \quad y_{i} \text{ fresh}}
    {\forall i \in [1,n].\; \bste{\ext {\Delta_{i}'}{x_i}{\langle
          % (\vdefer {(\sfixs f_1 \dots f_{n}).1},
          % \dots,
          % \vdefer {(\sfixs f_1 \dots f_{n}).n})
          [ \langle \vdefer {\Delta''\hspace{-0.5em}} {(\sfixs \stuple{y_1 \scomma \dots \scomma y_{n}}).j},\; \ell_{j} \rangle  ]_{j \in [1, n]}
          ,\; \ell_{i} \rangle}}{pc \sqcup \ell_{i}}{e_{i}'}{\smash{\overbrace{\langle v_{i},\; \ell_{i}' \rangle}^{\valpair v_{i}}}}}}
  {\bstep{\Delta}{pc}{\sfixs{e}}{[\valpair{v}_1, \dots, \valpair{v}_{n}]}{pc \sqcup \ell \sqcup \bigsqcup_{i=1}^{n} \ell_{i} \sqcup \bigsqcup_{i=1}^{n} \ell_{i}'}}\\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Let]}
  {\bstep{\Delta}{pc}{e_1}{v_1}{\ell_{1}}}
  {\ell_1 \sqsubseteq \llbracket a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\top}}
  {\bstep{\ext \Delta x {\langle v_1, \ell_1 \sqcup  \llbracket a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\bot}\rangle}}{pc}{e_2}{v}{\ell}}
  {\bstep{\Delta}{pc}{\slet {a_1~\dots~a_{n}} x {e_1} {e_2}}{v}{pc \sqcup \ell}} \\[1.5ex]\displaybreak[0]
  %
  % TODO rimettere?
  % \prftree[r]{[LetRec]}
  % {\prfStackPremises
  %   {\bstep{\Delta}{pc}{\sfix{\slam x {e_1}}}{v_1}{\ell_{1}}}
  %   {{\ell_1 \sqsubseteq \llbracket a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\top}} \quad
  %   {\bste{\ext \Delta x {\langle v_1, \ell_1 \sqcup  \llbracket a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\bot}\rangle}}{pc}{e_2}{\valpair v}}}}
  % {\bste{\Delta}{pc}{\sletrec {a_1~\dots~a_{n}} x {e_1} {e_2}}{\valpair v}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[LetRecAnd]}
  {\prfStackPremises
    {\bste{\Delta}{pc}{\sfixs{\stuple{
            \slam {x_{1}} {e_1}
            \scomma \dots \scomma
            \slam {x_m} {e_m}}
        }}{\langle [ \langle v_{i}, \ell_{i} \rangle ]_{i \in [1,m]} ,\; \ell \rangle}}
    {{\forall i \in [1,m].\; \ell_i \sqsubseteq \llbracket a_1^{i},\dots,a_{n}^{i} \rrbracket_{\mathrm{attr}}^{\top}} \quad
      {\valpair u_{i} \triangleq \langle v_i, \ell_i \sqcup  \llbracket a_1^{i},\dots,a_{n}^{i} \rrbracket_{\mathrm{attr}}^{\bot}\rangle}}
    {\bstep{\Delta[x_1 \mapsto \valpair u_{1}, \dots, x_m \mapsto \valpair u_{m}]}{pc}{e}{v}{\ell'}}}
  {\bstep{\Delta}{pc}{\texttt{let rec}~{a_1^{1}~\dots~a_{n_{1}}^{1}}~x_{i} = {e_1}~(\texttt{and}~{a_1^{i}~\dots~a_{n_{i}}^{i}}~x_{i} = e_i)_{i \in [2,m]}~\texttt{in}~e}{v}{pc \sqcup \ell'}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Module]}
  % {\forall i \in [1, n].\; \bstep {\Delta} {pc} {d_i} {\partial_i} {\ell_i}}
  {\bstep{\Delta}{pc}{\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}}{\vlam {\Delta'} x x}{\ell}}
  {\bstep{\Delta}{pc}{\smodule {d_1 \dots d_{n}}}{\vmodule{\Delta'_{\mid \left\{ x \;\mid\; \sexport x \,\in\, \left\{ d_1,\dots,d_{n} \right\}\right\}}}}{pc}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[TrustedModule]}
  % {\forall i \in [1, n].\; \bstep {\Delta} {pc} {d_i} {\partial_i} {\ell_i}}
  {\bstep{\ext \Delta {\mathrm{trusted}} {\true}}{pc}{\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}}{\vlam {\Delta'} x x}{\ell}}
  {\bstep{\Delta}{pc}{\strusted {d_1 \dots d_{n}}}{\vtrusted{\Delta'_{\mid \left\{ x \;\mid\; \sexport x \,\in\, \left\{ d_1,\dots,d_{n} \right\}\right\}}}}{pc}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Plugin]}
  {\prfStackPremises
    {\bstep{\varnothing}{\bot}{\text{read-file}(f)}{\vmodule{\Delta'}}{\ell}}
    {\Delta''(x) \triangleq
      \begin{cases}
        \text{apply-intf}(\Delta'(x),\tau) & (x:\tau) \in \left\{ i_1,\dots,i_{n} \right\} \\
        \mathrm{undefined} & \text{otherwise}
      \end{cases}}}
  {\bstep{\Delta}{pc}{\splugin f {i_1 \dots i_{n}}}{\vplugin{\Delta''}}{pc \sqcup \ell}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[FieldAccess]}
  {\bstep{\Delta}{pc}{e}{\textit{m}~{\Delta'}}{\ell}}
  {\Delta'(x) = \langle v, \ell' \rangle}
  {\textit{m} \in \left\{ \mathrm{mod}, \mathrm{tmod}, \mathrm{plug} \right\}}
  {\bstep{\Delta}{pc}{e.x}{v}{pc \sqcup \ell \sqcup \ell'}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[FieldAccessNoSecret]}
  {\bstep{\Delta}{pc}{e}{\textit{m}~{\Delta'}}{\ell}}
  {\Delta'(x) = \langle \vnosecret v, \ell' \rangle}
  {\textit{m} \in \left\{ \mathrm{mod}, \mathrm{tmod}, \mathrm{plug} \right\}}
  {\bstep{\Delta}{pc}{e.x}{\text{apply-nosecret}(v)}{pc \sqcup \ell \sqcup \ell'}}\\[4ex]\displaybreak[1]
  %
  \prftree[r]{[HasAttr]}
  {\bstep{\Delta}{pc}{e}{v}{\langle \ell_{C}, \ell_{I} \rangle}}
  {\bstep{\Delta}{pc}{\spredicate {attr} e}{attr = \ell_{C} \vee attr = \ell_{I}}{pc \sqcup \langle \ell_{C}, \ell_{I} \rangle}}\\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Declassify]}
  {\bstep{\Delta}{pc}{e}{v}{\langle \ell_{C}, \ell_{I} \rangle}}
  {\Delta(\mathrm{trusted}) = \true}
  {\bstepp{\Delta}{pc}{\sdeclassify e}{v}{\mathrm{public}}{\ell_{I}}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Endorse]}
  {\bstep{\Delta}{pc}{e}{v}{\langle \ell_{C}, \ell_{I} \rangle}}
  {\Delta(\mathrm{trusted}) = \true}
  {\bstepp{\Delta}{pc}{\sendorse e}{v}{\ell_{C}}{\mathrm{untainted}}}\\[4ex]\displaybreak[1]
\end{gather*}


read-file mette module/end


TODO: Check Module, Decl, finish Trusted and Plugin
Strict mode Let e Decl sempre \(\top\).

\begin{align*}
  \llbracket a_1,\dots,a_n \rrbracket_{\mathrm{attr}}^{\top} &= \bigsqcap_{i=1} \llbracket a_i \rrbracket_{\mathrm{attr}}^{\top} \qquad n \neq 1 \\
  \llbracket a_1,\dots,a_n \rrbracket_{\mathrm{attr}}^{\bot} &= \bigsqcup_{i=1} \llbracket a_i \rrbracket_{\mathrm{attr}}^{\bot} \qquad n \neq 1 \\
  \llbracket \texttt{secret} \rrbracket_{\mathrm{attr}}^{X} &= (\mathrm{secret}, X_{I}) \\
  \llbracket \texttt{public} \rrbracket_{\mathrm{attr}}^{X} &= (\mathrm{public}, X_{I}) \\
  \llbracket \texttt{tainted} \rrbracket_{\mathrm{attr}}^{X} &= (X_{C}, \mathrm{tainted}) \\
  \llbracket \texttt{untainted} \rrbracket_{\mathrm{attr}}^{X} &= (X_{C}, \mathrm{untainted})
\end{align*}

Note the meet and join of 0 elements are \(\top\) and \(\bot\), respectively.

\begin{align*}
  \llbracket \varepsilon \rrbracket_{\mathrm{mod \to let}} &\triangleq \slam{x}{x} \\
  \llbracket \sdlet {\mathit{attr}{*}} x e, d_1, \dots,d_{n} \rrbracket_{\mathrm{mod \to let}} &\triangleq \slet {\mathit{attr}{*}} x e {\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}} \\
  \left\llbracket
  \begin{aligned}
    &\left.\begin{aligned}
      &\texttt{let rec}~{a_1^{1}~\dots~a_{n_{1}}^{1}}~x_{i} = {e_1} \\
      &(\texttt{and}~{a_1^{i}~\dots~a_{n_{i}}^{i}}~x_{i} = e_i)_{i \in [2,m]},
    \end{aligned}\right\} l \\
    &d_1,\dots,d_{n}
  \end{aligned}
   \right\rrbracket_{{\mathrm{mod \to let}}} &\triangleq l \texttt{ in } {\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}}
\end{align*}

\begin{gather*}
  \prftree[r]{[Do]}
  {\forall i \in [1,n].\; \bste{\Delta}{pc}{e_{i}}{\valpair v_{i}}}
  {y~\text{fresh}}
  {\bste{\Delta}{pc}{\sdo{op}{e_1~\dots~e_{n}}}{\langle op, \vlam \Delta y y, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc \rangle}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[HandleRet]}
  {\bste{\Delta}{pc}{e}{\valpair v}}
  {(\texttt{return}~x=e_{\mathrm{ret}}) \in h}
  {\bste{\ext \Delta x {\valpair v}}{pc}{e_{\mathrm{ret}}}{\nu}}
  {\bste{\Delta}{pc}{\shandle h e}{\nu}} \\[1.5ex]\displaybreak[0]
  %
  % \prftree[r]{[HandleRetRaise]}
  % {\prfStackPremises
  % {{\bste{\Delta}{pc}{e}{\valpair v}} \quad {(\texttt{return}~x=e_{\mathrm{ret}}) \in h}}
  % {\bste{\ext \Delta x {\valpair v}}{pc}{e_{\mathrm{ret}}}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}}
  % {\bste{\Delta}{pc}{\shandle h e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc'\rangle}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[HandleRaise]}
    {\bste{\Delta}{pc}{e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
    {(op~x_1~\dots~x_{n}~k=e_{\mathrm{op}}) \notin h}
    {y~\text{fresh}}
  {\bste{\Delta}{pc}{\shandle h e}{\langle op, \vlam \Delta y {\shandle h {c~y}}, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[HandleOp]}
  {\prfStackPremises
    {\bste{\Delta}{pc}{e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
    {(op~x_1~\dots~x_{n}~k=e_{\mathrm{op}}) \in h}
    {{c' = \vlam \Delta y {\shandle h {c~y}}} \quad {y~\text{fresh}}}
    {\bste{\Delta[x_1 \mapsto \valpair v_1,\dots,x_{n} \mapsto \valpair v_{n}, k \mapsto \langle c', pc' \rangle]}{pc'}{e_{\mathrm{op}}}{\nu}}}
  {\bste{\Delta}{pc}{\shandle h e}{\nu}} \\[4ex]\displaybreak[1]
  %
  % \prftree[r]{[HandleOpRaise]}
  % {\prfStackPremises
  %   {\bste{\Delta}{pc}{e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
  %   {(op~x_1~\dots~x_{n}~k=e_{\mathrm{op}}) \in h}
  %   {{c' = \vlam \Delta y {\shandle h {c~y}}} \quad {y~\text{fresh}}}
  %   {\bste{\Delta[x_1 \mapsto \valpair v_1,\dots,x_{n} \mapsto \valpair v_{n}, k \mapsto \langle c', pc' \rangle]}{pc'}{e_{\mathrm{op}}}{\langle op', c', \langle \valpair v_1',\dots,\valpair v_{n}' \rangle, pc'' \rangle}}}
  % {\bste{\Delta}{pc}{\shandle h e}{{\langle op', c', \langle \valpair v_1',\dots,\valpair v_{n}' \rangle, pc'' \rangle}}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[BopRaiseL]}
  {\bste{\Delta}{pc}{e_1}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
  {y~\text{fresh}}
  {\bste{\Delta}{pc}{e_1~\mathit{bop}~e_2}{\langle op, \vlam \Delta y {(c~y)~\mathit{bop}~e_2, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc'\rangle}}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[BopRaiseR]}
  {\bste{\Delta}{pc}{e_1}{\valpair v}}
  {\bste{\Delta}{pc}{e_2}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
  {x,y~\text{fresh}}
  {\bste{\Delta}{pc}{e_1~\mathit{bop}~e_2}{\langle op, \vlam {\ext \Delta x {\valpair v}} y {x~\mathit{bop}~(c~y), \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc'\rangle}}} \\[1.5ex]\displaybreak[0]
\end{gather*}

% \begin{align*}
%   \text{check-type}(v, \tau) =
%   \begin{cases}
%     \true & \begin{aligned}[t]
%       (\tau &=\stint \wedge v \in \mathrm{Int}) \\
%       {}\vee (\tau &= \ststring \wedge v \in \mathrm{Str}) \\
%       {}\vee (\tau &= \stbool \wedge v \in \mathrm{Bool}) \\
%       {}\vee (\tau &= \stuple{\tau_1\scomma \dots \scomma \tau_n} \wedge v = \stuple{v_1\scomma \dots \scomma v_n} \\
%       &\wedge \bigwedge_{i=1}^{n} \text{check-type}(v_{i}, \tau_{i}))
%     \end{aligned} \\
%     \false & \text{otherwise} % \tau = \tau_1 \to \tau_2 \\
%     % \text{undefined} & \text{otherwise}
%   \end{cases}
% \end{align*}

\begin{align*}
  &\text{apply-intf}(\langle v, \ell \rangle, \tau) =
  \begin{dcases}
    \langle v, \ell'\rangle & \begin{aligned}
      \tau &= \stany \\
      {}\vee (\tau &=\stint \wedge v \in \mathrm{Int}) \\
      {}\vee (\tau &= \ststring \wedge v \in \mathrm{Str}) \\
      {}\vee (\tau &= \stbool \wedge v \in \mathrm{Bool})
    \end{aligned} \\
    \langle v:\tau, \ell' \rangle & \tau = \tau_1 \to \tau_2 \\
    \begin{aligned}
      \langle [&\text{apply-intf}(\valpair{v}_1,\tau_1),
      \dots, \\
      &\text{apply-intf}(\valpair{v}_n,\tau_n)
      ], \ell' \rangle
    \end{aligned}
    & \tau = \stuple{\tau_1\scomma \dots \scomma \tau_n} \wedge v = [\valpair{v}_1, \dots , \valpair{v}_n] \\
    \vnosecret {\text{apply-intf}(\langle v', \ell \rangle, \tau)} & v = \vnosecret {v'}\\
    \text{undefined} & \text{otherwise}
  \end{dcases} \\
&\quad\text{where } \ell' \triangleq \ell \sqcup \langle \mathrm{public}, \mathrm{tainted} \rangle
\end{align*}

\begin{align*}
  &\text{apply-nosecret}(\langle v, \overbrace{\langle \mathrm{public}, \ell_{I} \rangle}^{\ell}\rangle) =
  \begin{dcases}
    \langle v, \ell \rangle & v \in \mathrm{Int} \cup \mathrm{Str} \cup \mathrm{Bool} \\
    \langle \vnosecret v, \ell \rangle & v \in \mathrm{Fun} \cup \mathrm{Mod} \\
    \begin{aligned}
      \langle [&\text{apply-nosecret}(\valpair{v}_1),
      \dots, \\
      &\text{apply-nosecret}(\valpair{v}_n)
      ], \ell \rangle
    \end{aligned}
    & v = [\valpair{v}_1, \dots , \valpair{v}_n] \\
    \langle \text{apply-nosecret}(v') : \tau, \ell \rangle & v = v' : \tau \\
    \langle v, \ell \rangle & v = \vnosecret v'
  \end{dcases}
  \\[2ex]
  &\text{apply-nosecret}(\langle v, \langle \mathrm{secret}, \ell_{I} \rangle\rangle) = \mathrm{undefined} 
\end{align*}


TODO pc in e2 BopRaiseL
TODO join pc pc' in HandleOp?

TODO label App e Fix

TODO fix* lambda più parametri c'è un solo ambiente cosa vuol dire; si può togliere join?

dire cosa sono c, k, valpair, \(\nu\), \(a\) (attributi)


let x = declassify asd in x
non fa niente se pc è secret, mettere operatore che fa declassify di pc


TODO \(\ell\) in LetRecAnd non usato


\end{document}



do print
do print








trusted fn pippo x = controlla x; endorse x



let y =
  if <condizione tainted>
    4
  else
    3

pippo y

