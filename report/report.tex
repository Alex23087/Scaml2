\documentclass[a4paper, 12pt]{article}
\usepackage[top=2.5cm, bottom=2.5cm, left=3cm, width=15.09cm]{geometry}

\usepackage{mlmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage{mathtools,stmaryrd,galois,amsmath,amssymb,amsthm,prftree}
\usepackage{graphicx,tikz,quiver}
\usepackage{mleftright,xspace}

\usepackage{listings,lstautogobble}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  autogobble=true,
  xleftmargin=2em,
  literate={lam.}{{$\lambda$}}1,
  showstringspaces=false,
}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\renewcommand*{\O}[1]{\mathrm{O}(#1)}
\newcommand*{\wdeg}[1]{\operatorname{wdeg}{#1}}

\newcommand*{\abs}[1]{\left| #1 \right|}
\newcommand*{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand*{\floor}[1]{\left\lfloor #1 \right\rfloor}

\newcommand*{\pr}[1]{\mathrm{P}\!\left( #1 \right)}

\newcommand*{\lam}[2]{\lambda #1.\;#2}
\newcommand*{\ext}[3]{#1[#2 \mapsto #3]}

\DeclareMathOperator{\subtype}{\scalebox{0.6}[1]{$<$}\hspace{-0.75pt}\raisebox{0.25pt}{:}}
\DeclareMathOperator{\nsubtype}{\scalebox{0.8}{$\not$}\hspace{-0.2pt}\scalebox{0.6}[1]{$<$}\hspace{-0.75pt}\raisebox{0.25pt}{:}}
\DeclareMathOperator{\supertype}{\reflectbox{$\subtype$}}
\DeclareMathOperator{\nsupertype}{\reflectbox{$\nsubtype$}}

\newcommand*{\Fsub}{\ensuremath{F_{\subtype}}}
\newcommand*{\lambdasub}{\ensuremath{\lambda_{\subtype}}}

\DeclareMathOperator{\domin}{\geq\hspace{-3.5pt}\geq}

\newcommand*{\dom}[1]{\operatorname{dom}\!\left( #1 \right)}
\newcommand*{\cod}[1]{\operatorname{cod}\!\left( #1 \right)}
\newcommand*{\id}{\mathrm{id}}
\newcommand*{\op}{^{\mathrm{op}}}
\newcommand*{\inv}{^{-1}}

\newenvironment{grammar}
  {\newcommand*{\is}{&::=&}
   \newcommand*{\alt}{\;\mid\;}
   \newcommand*{\altnl}{\\&\mid&}
   \newcommand*{\isin}{&\in&}
   \[\begin{array}{rrll}}
  {\end{array}\]}

\newcommand*{\bste}[4]{#1, #2 \vdash #3 \Downarrow #4}
\newcommand*{\bstep}[5]{#1, #2 \vdash #3 \Downarrow \langle #4,\; #5\rangle}
\newcommand*{\bstepp}[6]{#1, #2 \vdash #3 \Downarrow \langle #4,\; \langle  #5,\; #6\rangle \rangle}

\newcommand*{\diverges}[2]{\langle #1, #2 \rangle \Uparrow}
\newcommand*{\slam}[2]{\lambda #1.\;#2}
\newcommand*{\slet}[4]{\texttt{let}~#1~#2~\texttt{=}~#3~\texttt{in}~#4}

\newcommand*{\sletrec}[4]{\texttt{let rec}~#1~#2 = #3~\texttt{in}~#4}
\newcommand*{\sletrecand}[5]{\texttt{let rec}~#1~#2 = #3~\texttt{and}~#4~\texttt{in}~#5}
\newcommand*{\sseq}{\texttt{;}}
\newcommand*{\sif}[3]{\texttt{if}~#1~\texttt{then}~#2~\texttt{else}~#3}
\newcommand*{\sfix}[1]{\texttt{fix}~#1}
\newcommand*{\sfixs}[1]{\texttt{fix*}~#1}
\newcommand*{\shandle}[2]{\texttt{with}~#1~\texttt{handle}~#2}
\newcommand*{\sdo}[2]{\texttt{do}~#1~#2}
\newcommand*{\smodule}[1]{\texttt{module}~#1~\texttt{end}}
\newcommand*{\strusted}[1]{\texttt{trusted module}~#1~\texttt{end}}
\newcommand*{\splugin}[2]{\texttt{plugin}~#1~#2~\texttt{end}}
\newcommand*{\stint}{\texttt{int}}
\newcommand*{\ststring}{\texttt{string}}
\newcommand*{\stbool}{\texttt{bool}}
\newcommand*{\stany}{\texttt{any}}
\newcommand*{\stfun}[2]{#1~\texttt{->}~#2}
\newcommand*{\sdlet}[3]{\texttt{let}~#1~#2 = #3}
\newcommand*{\sdletand}[4]{\texttt{let}~#1~#2 = #3~\texttt{and}~#4}
\newcommand*{\sdletrec}[3]{\texttt{let rec}~#1~#2 = #3}
\newcommand*{\sexport}[1]{\texttt{export}~#1}
\newcommand*{\stuple}[1]{\texttt{[}#1\texttt{]}}
\newcommand*{\scomma}{\texttt{,}}
\newcommand*{\sproj}[2]{#1\texttt{[} #2 \texttt{]}}
\newcommand*{\sassert}[1]{\texttt{assert}~#1}
\newcommand*{\slength}[1]{\texttt{length}~#1}

\newcommand*{\vmodule}[1]{\text{mod}~#1}
\newcommand*{\vtrusted}[1]{\text{tmod}~#1}
\newcommand*{\vplugin}[1]{\text{plug}~#1}

\newcommand*{\vlam}[3]{\lambda^{#1} #2.\;#3}

\newcommand*{\true}{\mathbf{tt}}
\newcommand*{\false}{\mathbf{ff}}

\newcommand*{\valpair}{\mathbf}

\newcommand*{\sdie}[1]{\texttt{die}}
\newcommand*{\spredicate}[2]{\texttt{has\_attr}~#1~#2}

\newcommand*{\sprint}[1]{\texttt{print}~#1}
\newcommand*{\sget}{\texttt{get}}

\newcommand*{\vdefer}[2]{\mathrm{defer}^{#1}~#2}
\newcommand*{\vprivate}{\mathrm{private}}
\newcommand*{\vexport}{\mathrm{export}}
\newcommand*{\vnosecret}[1]{\mathrm{nosecret}~#1}

\newcommand*{\soptional}[1]{#1{\!\!?}}

\newcommand*{\sdeclassify}[1]{\texttt{declassify}~#1}
\newcommand*{\sendorse}[1]{\texttt{endorse}~#1}
\newcommand*{\sdeclassifypc}[1]{\texttt{declassify\_pc}~#1}
\newcommand*{\sendorsepc}[1]{\texttt{endorse\_pc}~#1}

\newcommand*{\scaml}{ScaML$^{2}$\xspace}

\definecolor{grigio}{rgb}{0.9, 0.9, 0.9}

\title{LBTS project report -- \scaml}
\author{Andrea Simone Costa \and Alessio Du√® \and Alessandro Scala}

\begin{document}

\maketitle

\section{Syntax}

The syntax of \clap{\phantom{\footnote{}}}ScaML\footnote{From the names of its authors}
is inspired by OCaml. Some notable differences include:
\begin{itemize}
\item \texttt{let} bindings accept a list of attributes, like \texttt{public} or \texttt{tainted};
\item operators for endorsing and declassifying values;
\item assertions and predicates on attributes of values;
\item plugins, with dynamically checked interfaces.
\end{itemize}

\begin{grammar}
  e \is x \alt v \alt e.x \alt \texttt{(} e \texttt{)}
  \altnl e~\mathit{bop}~e \alt \mathit{uop}~e
  \alt \stuple{e \scomma \dots \scomma e} \alt \sproj e e \alt \slength{e}
  \altnl e~e \alt \slam x e \alt \sfix e \alt \sfixs e\alt \mathit{let}
  \altnl \sif e e e
  \altnl \shandle h e \alt \sdo {\mathit{op}} {e*} %HAND
  \altnl \smodule {d{*}} \alt \strusted {d{*}} \alt \splugin s {\mathit{intf}{*}}
  \altnl \sdie e \alt \sassert e \alt \spredicate {\mathit{attr}} e
  \altnl \sdeclassify e \alt \sendorse e \alt \sdeclassifypc e \alt \sendorsepc e
  \altnl \sprint e \alt \sget
  \\
  \\
  \mathit{let} \is \slet {\mathit{attr}{*}} x e e
  \altnl \texttt{let rec}~{\mathit{attr}{*}}~x = e~(\texttt{and}~\mathit{attr}{*}~x = e){*}~\texttt{in}~e
  \\
  \\
  % b \is x \alt \stuple{b \scomma \dots \scomma b}
  % \\
  % \\
  \mathit{intf} \is x~\texttt{:}~\tau
  \\
  d \is \sdlet {\mathit{attr}{*}} x e
  \altnl \sdletrec {\mathit{attr}{*}} x e~(\texttt{and}~d){*}
  \altnl \sexport x
  \\
  \\
  h \is \texttt{\{} (\mathit{op}~x+ = e\texttt{,}){*}~\texttt{return}~x = e \texttt{\}} %HAND
  \\
  \\
  v \isin \mathrm{Int} \cup \mathrm{Str} \cup \mathrm{Bool}
  % m \is \vmodule {d{*}} \alt \vtrusted {d{*}} \alt \vplugin {i{*}} {d{*}}
  \\
  s \isin \mathrm{Str}
  \\
  x,\mathit{op} \isin \mathrm{Ide}
  \\
  \\
  \mathit{attr} \is \texttt{public} \alt \texttt{secret} \alt \texttt{tainted} \alt \texttt{untainted}
  \\
  \tau \is \stany \alt \stint \alt \ststring \alt \stbool \alt \stfun \tau \tau \alt \stuple{\tau \scomma \dots \scomma \tau} \alt \texttt{(} \tau \texttt{)}
\end{grammar}

\section{Operational semantics}

% % https://q.uiver.app/#q=WzAsNCxbMSw0LCIoXFxtYXRocm17cHVibGljfSwgXFxtYXRocm17dW50YWludGVkfSkiXSxbMiwyLCIoXFxtYXRocm17cHVibGljfSwgXFxtYXRocm17dGFpbnRlZH0pIl0sWzAsMiwiKFxcbWF0aHJte3NlY3JldH0sIFxcbWF0aHJte3VudGFpbnRlZH0pIl0sWzEsMCwiKFxcbWF0aHJte3NlY3JldH0sIFxcbWF0aHJte3RhaW50ZWR9KSJdLFswLDIsIiIsMCx7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMiwzLCIiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzAsMSwiIiwyLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsxLDMsIiIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XV0=
% \[\begin{tikzcd}
%     & {(\mathrm{secret}, \mathrm{tainted})} \\
%     \\
%     {(\mathrm{secret}, \mathrm{untainted})} && {(\mathrm{public}, \mathrm{tainted})} \\
%     \\
%     & {(\mathrm{public}, \mathrm{untainted})}
%     \arrow[no head, from=3-1, to=1-2]
%     \arrow[no head, from=3-3, to=1-2]
%     \arrow[no head, from=5-2, to=3-1]
%     \arrow[no head, from=5-2, to=3-3]
%   \end{tikzcd}\]

Values are tagged with labels, which belong to a lattice Lbl. Lbl is itself
the product of the confidentiality and integrity lattices, \(I\) and \(C\), defined by the following Hasse diagrams:
% https://q.uiver.app/#q=WzAsOSxbMSwzLCJcXG1hdGhybXtwdWJsaWN9Il0sWzAsMiwiXFxtYXRocm17c2VjcmV0fV4xX3t9Il0sWzEsMiwiXFxtYXRocm17c2VjcmV0fV4yIl0sWzEsMSwiXFxtYXRocm17c2VjcmV0fV4wIl0sWzEsMCwiQyJdLFs0LDAsIkkiXSxbNCwxLCJcXG1hdGhybXt0YWludGVkfSJdLFs0LDMsIlxcbWF0aHJte3VudGFpbnRlZH0iXSxbMiwyLCJcXG1hdGhybXtzZWNyZXR9Xm4iXSxbMCwxLCIiLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzEsMywiIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFsyLDMsIiIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMCwyLCIiLDIseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzYsNywiIiwwLHsic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDgsIiIsMix7InN0eWxlIjp7ImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbOCwzLCIiLDIseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJub25lIn19fV0sWzIsOCwiXFxjZG90cyIsMSx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFs4LDEzLCJcXHRpbWVzIiwxLHsibGFiZWxfcG9zaXRpb24iOjQwLCJzaG9ydGVuIjp7InRhcmdldCI6MjB9LCJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJub25lIn0sImhlYWQiOnsibmFtZSI6Im5vbmUifX19XSxbMTAsMTEsIiIsMyx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7ImJvZHkiOnsibmFtZSI6Im5vbmUifSwiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dXQ==
\[\begin{tikzcd}
	& C &&& I \\
	& {\mathrm{secret}^0} &&& {\mathrm{tainted}} \\
	{\mathrm{secret}^1_{}} & {\mathrm{secret}^2} & {\mathrm{secret}^n} \\
	& {\mathrm{public}} &&& {\mathrm{untainted}}
	\arrow[""{name=0, anchor=center, inner sep=0}, no head, from=2-5, to=4-5]
	\arrow[""{name=1, anchor=center, inner sep=0}, no head, from=3-1, to=2-2]
	\arrow[""{name=2, anchor=center, inner sep=0}, no head, from=3-2, to=2-2]
	\arrow["\cdots"{description}, draw=none, from=3-2, to=3-3]
	\arrow[no head, from=3-3, to=2-2]
	\arrow[no head, from=4-2, to=3-1]
	\arrow[no head, from=4-2, to=3-2]
	\arrow[no head, from=4-2, to=3-3]
	\arrow[draw=none, from=1, to=2]
	\arrow["\times"{description, pos=0.4}, draw=none, from=3-3, to=0]
\end{tikzcd}\]

\(\mathrm{secret}^p\) is the confidentiality label of a secret value created in
the \(p\)-th plugin; in particular \(p=0\) is used for the modules defined in the main program file.

We define the big-step operational semantics relation, with signature:
\[ {\Downarrow} : \mathrm{Env} \times \underbrace{\mathrm{Lbl}}_{pc} \times \mathrm{Exp} \to \mathrm{Val} \cup \underbrace{(\mathrm{Ide} \times \mathrm{Fun} \times \mathrm{Val}^* \times \mathrm{Lbl})}_{\text{for raising operations}} \] %HAND
where:
\begin{align*}
  \mathrm{Val} &= \mathrm{BareVal} \times \mathrm{Lbl}
  \\
  \mathrm{BareVal} &= \mathrm{Int} \cup \mathrm{Str} \cup \mathrm{Bool} \cup \mathrm{Fun} \cup \underbrace{\mathrm{Val}^*}_{\text{tuples}} \cup \mathrm{Defer} \cup \mathrm{Mod} \cup \underbrace{\mathrm{ValType}}_{\mathclap{\text{value with interface}}} % \cup \mathrm{NoSecret}
  % \\
  % \mathrm{NoSecret} &= \left\{ \vnosecret v \mid v \in \mathrm{BareVal} \right\}
  \\
  \\
  \mathrm{Int} &= \mathbb N \\
  \mathrm{Str} &= \mathrm{ASCII}^* \\
  \mathrm{Bool} &= \left\{ \true, \false \right\}
  \\
  \\
  \mathrm{Env} &= \mathrm{Val}^{\mathrm{Ide} \,\cup\, \left\{ \mathrm{@trusted}, \mathrm{@plugin} \right\}}
  \\
  \mathrm{Fun} &= \left\{ \vlam \Delta x e \mid \Delta \in \mathrm{Env}, x \in \mathrm{Ide}, e \in \mathrm{Exp} \right\}
  \\
  \mathrm{Defer} &= \left\{ \vdefer \Delta e \mid \Delta \in \mathrm{Env}, e \in \mathrm{Exp} \right\}
  \\
  \\
  \mathrm{Mod} &=
                   \left\{\vmodule \Delta \mid \Delta \in \mathrm{Env}\right\}
                   \cup \left\{\vtrusted \Delta \mid \Delta \in \mathrm{Env}\right\}
                   \cup \left\{\vplugin \Delta \mid \Delta \in \mathrm{Env}\right\}
  \\
  \\
  \mathrm{ValType} &= \left\{ v : \tau \mid v \in \mathrm{BareVal}, \tau \in \mathrm{Type} \right\}
\end{align*}
and Exp is the set of syntactic elements generated by the nonterminal \(e\) in the grammar,
and Type by the nonterminal \(\tau\).

Defer values are needed to implement the fixpoint operators \texttt{fix} and \texttt{fix*},
they cannot be created by the user. Modules are environments tagged with the module kind:
simple module, trusted module or plugin.\footnote{Actually, this distinction is not strictly needed for the semantics of (trusted) modules and plugins, but we keep it in order to be able to print them differently.} Modules are program units used to group together code relative to a functionality. Since each module has its own environment and only exposes names declared with \(\sexport{}\)\llap{,} they are useful to provide encapsulation, giving complete control to the programmer about what is exposed and what is hidden. Every program file implicitly defines a module, and therefore has to follow module syntax. @trusted and @plugin are special identifiers used to keep track of the trustedness level and plugin identifier in environments.

Following are the inference rules. We begin with simple rules for values, variables and tuple projections and length:
\begin{gather*}
  \prftree[r]{[Val]}{\bstep{\Delta}{pc}{v}{\llbracket v \rrbracket}{pc}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Lam]}{\bstep{\Delta}{pc}{\slam x e}{\vlam \Delta x e}{pc}} \\[1.5ex]\displaybreak[0]
  \prftree[r]{[Tuple]}
  {\forall i \in [1,n].\; \bstep{\Delta}{pc}{e_i}{v_i}{\ell_i} \triangleq \valpair v_{i}}
  {\bstep{\Delta}{pc}{\stuple{e_1\scomma \dots\scomma e_{n}}}{[\valpair v_1, \dots, \valpair v_{n}]}{pc \sqcup \bigsqcup_{i = 1}^{n} \ell_{i}}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Var]}
  {\Delta(x) = \langle v, \ell \rangle}
  {v \neq \vdefer {\Delta'} e}
  {\bstep{\Delta}{pc}{x}{v}{pc \sqcup \ell}}
  \qquad
  \prftree[r]{[VarDefer]}
  {\Delta(x) = \langle \vdefer {\Delta'} e, \ell_1 \rangle}
  {\bstep{\Delta'}{pc}{e}{v}{\ell_2}}
  {\bstep{\Delta}{pc}{x}{v}{pc \sqcup \ell_1 \sqcup \ell_2}}
  \\[4ex]\displaybreak[1]
  \prftree[r]{[Proj]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_1}{[ \langle v_j, \ell_{v_{j}} \rangle]_{j \in [0,\dots,n-1]}}{\ell_1}}
    {{\bstep{\Delta}{pc}{e_2}{i}{\ell_2}}
    \quad {0 \leq i \leq n-1}}
  {v_{i} \neq \vdefer {\Delta'} e}}
  {\bstep{\Delta}{pc}{\sproj {e_1} {e_2}}{v_{i}}{pc \sqcup \ell_1 \sqcup \ell_2 \sqcup \ell_{v_i}}}
  \\[1.5ex]\displaybreak[0]
  \prftree[r]{[ProjDefer]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_1}{[ \langle v_j, \ell_{v_{j}} \rangle]_{j \in [0,\dots,n-1]}}{\ell_1}}
    {\bstep{\Delta}{pc}{e_2}{i}{\ell_2} \quad {0 \leq i \leq n-1}}
    {v_{i} = \vdefer {\Delta'} e \quad \bstep{\Delta'}{pc}{e}{v}{\ell_3}}}
  {\bstep{\Delta}{pc}{\sproj {e_1} {e_2}}{v}{pc \sqcup \ell_1 \sqcup \ell_2 \sqcup \ell_{v_i} \sqcup \ell_3}}
  \\[1.5ex]\displaybreak[0]
  \prftree[r]{[Length]}
  {\bstep{\Delta}{pc}{e}{[ \valpair v_j ]_{j \in [0,\dots,n-1]}}{\ell}}
  {\bstep{\Delta}{pc}{\slength{e}}{n}{pc \sqcup \ell}}
  \\%[1.5ex]\displaybreak[0]
\end{gather*}
The idea of deferred expressions is that \(\vdefer {\Delta} e\) automatically evaluates \(e\) in environment \(\Delta\) when the defer is extracted from the environment or a tuple field.

Then we have rules for application:
\begin{gather*}
  \prftree[r]{[App]}
  {\bstep{\Delta}{pc}{e_1}{\vlam {\Delta'} x e}{\ell_{f}}}
  {\bste{\Delta}{pc}{e_2}{\valpair v}}
  {\bstep{\ext {\Delta'} x {\valpair v}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}}}
  {\bstep{\Delta}{pc}{e_1~e_2}{u}{pc \sqcup \ell_{f} \sqcup \ell_{u}}} \\[1.5ex]\displaybreak[0]
  %
  % \prftree[r]{[AppNoSecret]}
  % {\bstep{\Delta}{pc}{e_1}{\vnosecret f}{\ell_{f}}}
  % {\bstep{\Delta}{pc}{\valpair f~e_2}{asd}{\ell_{f}}}
  % {\bstep{\Delta}{pc}{e_1~e_2}{\text{apply-nosecret}()}{pc}} \\[1.5ex]\displaybreak[0]
  % \prftree[r]{[AppNoSecret]}
  % {\prfStackPremises
  %   {{\bstep{\Delta}{pc}{e_1}{\vnosecret {\vlam {\Delta'} x e}}{\ell_{f}}}
  %   \quad {\bste{\Delta}{pc}{e_2}{\valpair v}}}
  %   {\bstep{\ext {\Delta'} x {\valpair v}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}} \triangleq \valpair u}}
  % {\bstep{\Delta}{pc}{e_1~e_2}{\text{apply-nosecret}(\valpair u)}{pc \sqcup \ell_{f} \sqcup \ell_{u}}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[AppIntf]}
  {\prfStackPremises
    {{\bstep{\Delta}{pc}{e_1}{(\vlam {\Delta'} x e) : \tau_1 \to \tau_2}{\ell_{f}}}
    \quad \bste{\Delta}{pc}{e_2}{\valpair v}
      % \quad \valpair v' \triangleq \text{apply-nosecret}(\valpair v)
      \quad \valpair v' \triangleq \text{apply-intf}(\valpair v, \tau_1)}
    {\bstep{\ext {\Delta'} x {\valpair v'}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}} \triangleq \valpair u
    \quad \langle u', \ell_{u}' \rangle \triangleq \text{apply-intf}(\valpair u, \tau_2)}}
  {\bstep{\Delta}{pc}{e_1~e_2}{u'}{pc \sqcup \ell_{f} \sqcup \ell_{u}'}} % \\[4ex]\displaybreak[1]
  %
  % \prftree[r]{[AppIntfNoSecret]}
  % {\prfStackPremises
  %   {\bstep{\Delta}{pc}{e_1}{\vnosecret {(\vlam {\Delta'} x e) : \tau_1 \to \tau_2}}{\ell_{f}}}
  %   {\bste{\Delta}{pc}{e_2}{\valpair v}
  %     \quad \valpair v' \triangleq \text{apply-nosecret}(\valpair v)
  %     \quad \valpair v'' \triangleq \text{apply-intf}(\valpair v', \tau_1)}
  %   {\bstep{\ext {\Delta'} x {\valpair v'}}{pc \sqcup \ell_{f}}{e}{u}{\ell_{u}} \triangleq \valpair u
  %   \quad \valpair u' \triangleq \langle u', \ell_{u}' \rangle \triangleq \text{apply-intf}(\valpair u, \tau_2)}}
  % {\bstep{\Delta}{pc}{e_1~e_2}{\text{apply-nosecret}(\valpair u')}{pc \sqcup \ell_{f} \sqcup \ell_{u}'}} \\[4ex]\displaybreak[1]
  %
\end{gather*}
Application is standard if \(e_1\) evaluates to a closure. If instead it evaluates to a closure tagged with a type \(\tau_1 \to \tau_2\) (its interface), then we need to check that the parameter and the result match \(\tau_1\) and \(\tau_2\). We do so with the help of the following function:
\begin{align*}
  &\text{apply-intf}(\langle v, \ell \rangle, \tau) =
  \begin{dcases}
    \langle v, \ell'\rangle & \begin{aligned}
      \tau &= \stany \\
      {}\vee (\tau &=\stint \wedge v \in \mathrm{Int}) \\
      {}\vee (\tau &= \ststring \wedge v \in \mathrm{Str}) \\
      {}\vee (\tau &= \stbool \wedge v \in \mathrm{Bool})
    \end{aligned} \\[1.5ex]
    \langle v:\tau, \ell' \rangle & \tau = \tau_1 \to \tau_2 \\[1.5ex]
    \begin{aligned}
      \langle [&\text{apply-intf}(\valpair{v}_1,\tau_1),
      \dots, \\
      &\text{apply-intf}(\valpair{v}_n,\tau_n)
      ], \ell' \rangle
    \end{aligned}
    & \tau = \stuple{\tau_1\scomma \dots \scomma \tau_n} \wedge v = [\valpair{v}_1, \dots , \valpair{v}_n] \\[1.5ex]
    % {\vnosecret {\langle v'', \ell' \rangle} } &
    %                               \begin{aligned}
    %                                 &v = \vnosecret {v'}\\
    %                                 &\wedge \langle v'', \ell' \rangle = {\text{apply-intf}(\langle v', \ell \rangle, \tau)}
    %                               \end{aligned} \\[1.5ex]
    \text{undefined} & \text{otherwise}
  \end{dcases} \\
&\quad\text{where } \ell' \triangleq \ell \sqcup \langle \mathrm{public}, \mathrm{tainted} \rangle
\end{align*}
\(\text{apply-intf}(\valpair v, \tau)\) checks that \(\valpair v\) has type \(\tau\) and, if $\valpair v$ is a tuple, propagates the interface to the components of \(\valpair v\).

Going on, we have rules for unary and binary operations (we assume to have a function \(\llbracket \cdot \rrbracket : \mathrm{Bop} \to (\mathrm{Val} \to \mathrm{Val} \to \mathrm{Val})\) that gives the semantic interpretation of each binary operation, and equivalently one for unary operations) and if expressions:
\begin{gather*}
  \prftree[r]{[Uop]}
  {\bstep{\Delta}{pc}{e}{v}{\ell}}
  {\bstep{\Delta}{pc}{\mathit{uop}~e}{\llbracket \mathit{uop} \rrbracket(v)}{pc \sqcup \ell}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Bop]}
  {\bstep{\Delta}{pc}{e_1}{v_1}{\ell_1}}
  {\bstep{\Delta}{pc}{e_2}{v_2}{\ell_2}}
  {\bstep{\Delta}{pc}{e_1~\mathit{bop}~e_2}{\llbracket \mathit{bop} \rrbracket(v_1, v_2)}{pc \sqcup \ell_1 \sqcup \ell_2}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[IfTrue]}
  {\bstep{\Delta}{pc}{e_c}{\true}{\ell_{c}}}
  {\bstep{\Delta}{pc \sqcup \ell_{c}}{e_t}{v}{\ell_t}}
  {\bstep{\Delta}{pc}{\sif {e_{c}} {e_{t}} {e_{e}}}{v}{pc \sqcup \ell_c \sqcup \ell_t}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[IfFalse]}
  {\bstep{\Delta}{pc}{e_c}{\false}{\ell_{c}}}
  {\bstep{\Delta}{pc \sqcup \ell_{c}}{e_e}{v}{\ell_e}}
  {\bstep{\Delta}{pc}{\sif {e_{c}} {e_{t}} {e_{e}}}{v}{pc \sqcup \ell_c \sqcup \ell_e}} \\[4ex]\displaybreak[1]
\end{gather*}

Let bindings also perform attribute checking and casting.
\(\slet {\textit{attrs}} x {e_1} {e_2}\) evaluates \(e_1\), checks that its
security label is compatible with attributes \textit{attrs}, then upcasts it to
\textit{attrs} if it was more permissive, and binds the result to \(x\) in the
evaluation of \(e_2\):
\begin{gather*}
  \prftree[r]{[Let]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_1}{v_1}{\ell_{1}}
      \quad p \triangleq \Delta(\mathrm{@plugin}) \quad \ell_1 \sqsubseteq \llbracket 0; a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\top}}
    {\bstep{\ext \Delta x {\langle v_1, \ell_1 \sqcup  \llbracket p; a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\bot}\rangle}}{pc}{e_2}{v}{\ell}}}
  {\bstep{\Delta}{pc}{\slet {a_1~\dots~a_{n}} x {e_1} {e_2}}{v}{pc \sqcup \ell}} \\[1.5ex]\displaybreak[0]
\end{gather*}

The functions \(\llbracket \cdot \rrbracket^{\top}_{\mathrm{attr}}\) and \(\llbracket \cdot \rrbracket^{\bot}_{\mathrm{attr}}\) are defined as:
\begin{align*}
  \llbracket p; a_1,\dots,a_n \rrbracket_{\mathrm{attr}}^{\top} &= \bigsqcap_{i=1} \llbracket p; a_i \rrbracket_{\mathrm{attr}}^{\top} \qquad n \neq 1 \\
  \llbracket p; a_1,\dots,a_n \rrbracket_{\mathrm{attr}}^{\bot} &= \bigsqcup_{i=1} \llbracket p; a_i \rrbracket_{\mathrm{attr}}^{\bot} \qquad n \neq 1 \\
  \llbracket p; \texttt{secret} \rrbracket_{\mathrm{attr}}^{X} &= (\mathrm{secret}^{p}, X_{I}) \\
  \llbracket p; \texttt{public} \rrbracket_{\mathrm{attr}}^{X} &= (\mathrm{public}, X_{I}) \\
  \llbracket p; \texttt{tainted} \rrbracket_{\mathrm{attr}}^{X} &= (X_{C}, \mathrm{tainted}) \\
  \llbracket p; \texttt{untainted} \rrbracket_{\mathrm{attr}}^{X} &= (X_{C}, \mathrm{untainted})
\end{align*}
Note the meet and join of 0 elements are \(\top\) and \(\bot\), respectively.

Essentially, \(\llbracket p; \textit{attrs} \rrbracket^{X}_{\mathrm{attr}}\) turns a list of attributes into an element of Lbl; if \(X=\top\), the result is the smallest element of the lattice compatible with \emph{attrs}, if \(X=\bot\) it is the greatest. We use \(X=\top\) when checking if the assignment is valid so that \(\texttt{let public secret x = <secret value>}\) is rejected, and \(X=\bot\) when casting so that with \(\texttt{let public secret x = <public value>}\), \texttt{x} is secret in the body.

With a slight change of the semantics, i.e. always using \(X=\top\), we could implement a \emph{strict mode} for the language: in that case, all \texttt{let}s with unspecified attributes become equivalent to \texttt{let secret tainted}. This is a sort of \emph{secure-by-default} stance and forces the programmer to explicitly state when a variable needs to be public or when it is untainted. This choice is similar to that of having immutable values by default and having to explicitly mark mutable ones, and the argument against it is that it makes variable definition more verbose.

There is also a rule that skips the evaluation of a deferred expression if it is immediatly bound in a \texttt{let}; this is needed to avoid divergence in the implementation of \texttt{let rec}:
\begin{gather*}
  \prftree[r]{[LetProj]}
  {\prfStackPremises
    {\bstep{\Delta}{pc}{e_t}{[ \langle v_j, \ell_{v_{j}} \rangle]_{j \in [0,\dots,n-1]}}{\ell_t}
      \quad {\bstep{\Delta}{pc}{e_i}{i}{\ell_i}}}
    {{0 \leq i \leq n-1}
      \quad \ell_{i}' \triangleq \ell_{v_{i}} \sqcup \ell_{i}}
    {p \triangleq \Delta(\mathrm{@plugin}) \quad \ell_i' \sqsubseteq \llbracket 0; a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\top}}
    {\bstep{\ext \Delta x {\langle v_i, \ell_i' \sqcup  \llbracket p; a_1,\dots,a_{n} \rrbracket_{\mathrm{attr}}^{\bot}\rangle}}{pc}{e_2}{v}{\ell}}}
  {\bstep{\Delta}{pc}{\slet {a_1~\dots~a_{n}} x {\sproj{e_t}{e_{i}}} {e_2}}{v}{pc \sqcup \ell}} \\[1.5ex]\displaybreak[0]
\end{gather*}

We also have fixpoint operators \texttt{fix} and \texttt{fix*} (for mutually recursive definitions), which are also used to implement \texttt{let rec} ... \texttt{and} definitions:
\begin{gather*}
  \prftree[r]{[Fix]}
  {\bstep{\Delta}{pc}{e}{\vlam {\Delta'} x {e'}}{\ell}}
  {\bstep{\ext {\Delta'}{x}{\langle \vdefer {\Delta'} {\sfix {\slam x {e'}}}, \ell \rangle}}{pc \sqcup \ell}{e'}{v}{\ell'}}
  {\bstep{\Delta}{pc}{\sfix e}{v}{pc \sqcup \ell \sqcup \ell'}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Fix*]}
  {\prfStackPremises
    % {\forall i \in [1,n].\; \bste{\Delta}{pc}{e_i}{\overbrace{\langle\vlam {\Delta_i'} {x_{i}} {e_i'},\;{\ell_i}\rangle}^{f_{i}}}}
    {\bstep{\Delta}{pc}{e}{[ \overbrace{\langle\vlam {\Delta_i'} {x_{i}} {e_i'},\;{\ell_i}\rangle}^{f_{i}} ]_{i \in [1,n]}}{\ell}}
    {\Delta'' \triangleq \Delta[y_1 \mapsto f_1,\dots,y_{n} \mapsto f_{n}] \quad y_{i} \text{ fresh}}
    {\forall i \in [1,n].\; \bste{\ext {\Delta_{i}'}{x_i}{\langle
          % (\vdefer {(\sfixs f_1 \dots f_{n}).1},
          % \dots,
          % \vdefer {(\sfixs f_1 \dots f_{n}).n})
          [ \langle \vdefer {\Delta''\hspace{-0.5em}} {\sproj{(\sfixs \stuple{y_1 \scomma \dots \scomma y_{n}})}{j}},\; \ell_{j} \rangle  ]_{j \in [1, n]}
          ,\; \ell_{i} \rangle}}{pc \sqcup \ell_{i}}{e_{i}'}{\smash{\overbrace{\langle v_{i},\; \ell_{i}' \rangle}^{\valpair v_{i}}}}}}
  {\bstep{\Delta}{pc}{\sfixs{e}}{[\valpair{v}_1, \dots, \valpair{v}_{n}]}{pc \sqcup \ell \sqcup \bigsqcup_{i=1}^{n} \ell_{i} \sqcup \bigsqcup_{i=1}^{n} \ell_{i}'}}\\[4ex]\displaybreak[1]
  %
  \prftree[r]{[LetRecAnd]} % TODO scrivere che let rec secret f = ... and g = ... g √® per forza secret
                           % e che \ell non serve
  {\prfStackPremises
    {\mathit{xs} \text{ fresh} \quad \mathrm{wrap}(e') \triangleq \slam{\mathit{xs}}{(\slet {a^{i}_{1}\dots a^{i}_{n_{i}}} {x_i} {\sproj {\mathit{xs}} {i-1}} {\!\!}})_{i \in [1,m]}~e'}
    {\bste{\Delta}{pc}{\sfixs{\stuple{
            \mathrm{wrap}(e_1)
            \scomma \dots \scomma
            \mathrm{wrap}(e_m)}
        }}{\langle [ \langle v_{i}, \ell_{i} \rangle ]_{i \in [1,m]} ,\; \ell \rangle}}
    {p \triangleq \Delta(\mathrm{@plugin}) \quad {\forall i \in [1,m].\; \ell_i \sqsubseteq \llbracket p; a_1^{i},\dots,a_{n_{i}}^{i} \rrbracket_{\mathrm{attr}}^{\top}}}
    {  {\valpair u_{i} \triangleq \langle v_i, \ell_i \sqcup  \llbracket p; a_1^{i},\dots,a_{n_{i}}^{i} \rrbracket_{\mathrm{attr}}^{\bot}\rangle} \quad
    \bstep{\Delta[x_1 \mapsto \valpair u_{1}, \dots, x_m \mapsto \valpair u_{m}]}{pc}{e}{v}{\ell'}}}
  {\bstep{\Delta}{pc}{\texttt{let rec}~{a_1^{1}~\dots~a_{n_{1}}^{1}}~x_{1} = {e_1}~(\texttt{and}~{a_1^{i}~\dots~a_{n_{i}}^{i}}~x_{i} = e_i)_{i \in [2,m]}~\texttt{in}~e}{v}{pc \sqcup \ell'}} %\\[4ex]\displaybreak[1]
\end{gather*}

Modules are first class values; at runtime they are environments that can be
passed around and accessed dynamically. To evaluate a module, we translate it to a chain of \texttt{let} expressions. The body of the final \texttt{let} is the expression \(\slam x x\); this is a trick to be able to extract the environment at the end of the evaluation of the module (since the lambda will produce a closure).

Only the identifiers which are explicitly exported are accessible outside the module. This is effectively achieved by restricting the environment resulting from the evaluation of the environment expression.

We keep track of whether the module was a simple \texttt{module} or a
\texttt{trusted module} through a binding of the special identifier @trusted.
\begin{gather*}
  \prftree[r]{[Module]}
  % {\forall i \in [1, n].\; \bstep {\Delta} {pc} {d_i} {\partial_i} {\ell_i}}
  {\bstep{\ext \Delta {\mathrm{@trusted}} {\false}}{pc}{\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}}{\vlam {\Delta'} x x}{\ell}}
  {\bstep{\Delta}{pc}{\smodule {d_1 \dots d_{n}}}{\vmodule{\Delta'_{\mid \left\{ x \;\mid\; \sexport x \,\in\, \left\{ d_1,\dots,d_{n} \right\}\right\}}}}{pc}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[TrustedModule]}
  % {\forall i \in [1, n].\; \bstep {\Delta} {pc} {d_i} {\partial_i} {\ell_i}}
  {\bstep{\ext \Delta {\mathrm{@trusted}} {\true}}{pc}{\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}}{\vlam {\Delta'} x x}{\ell}}
  {\bstep{\Delta}{pc}{\strusted {d_1 \dots d_{n}}}{\vtrusted{\Delta'_{\mid \left\{ x \;\mid\; \sexport x \,\in\, \left\{ d_1,\dots,d_{n} \right\}\right\}}}}{pc}}%\\[1.5ex]\displaybreak[0]
\end{gather*}
This is the definition of the translation from module syntax to let expressions:
\begin{align*}
  \llbracket \varepsilon \rrbracket_{\mathrm{mod \to let}} &\triangleq \slam{x}{x} \\
  \llbracket \sexport x, d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}} &\triangleq \llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}} \\
  \llbracket \sdlet {\mathit{attr}{*}} x e, d_1, \dots,d_{n} \rrbracket_{\mathrm{mod \to let}} &\triangleq \slet {\mathit{attr}{*}} x e {\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}} \\
  \left\llbracket
  \begin{aligned}
    &\left.\begin{aligned}
      &\texttt{let rec}~{a_1^{1}~\dots~a_{n_{1}}^{1}}~x_{i} = {e_1} \\
      &(\texttt{and}~{a_1^{i}~\dots~a_{n_{i}}^{i}}~x_{i} = e_i)_{i \in [2,m]},
    \end{aligned}\right\} l \\
    &d_1,\dots,d_{n}
  \end{aligned}
   \right\rrbracket_{{\mathrm{mod \to let}}} &\triangleq l \texttt{ in } {\llbracket d_1,\dots,d_{n} \rrbracket_{\mathrm{mod \to let}}}
\end{align*}


\texttt{plugin} expressions are composed of a file name and a list of interfaces. The file is parsed and evaluated, resulting in a module (its content is implicitly wrapped with \texttt{module} ... \texttt{end}). Then, we apply the specified interfaces to the bindings contained in that module, discarding the bindings that do not have one.
\begin{gather*}
  \prftree[r]{[Plugin]}
  {\prfStackPremises
    {p~\text{fresh plugin number}}
    {\bstep{\ext{\varnothing}{\mathrm{@plugin}}{p}}{\bot}{\text{read-file}(f)}{\vmodule{\Delta'}}{\ell}}
    {\Delta''(x) \triangleq
      \begin{cases}
        \text{apply-intf}(\Delta'(x),\tau) & (x:\tau) \in \left\{ i_1,\dots,i_{n} \right\} \\
        \mathrm{undefined} & \text{otherwise}
      \end{cases}}}
  {\bstep{\Delta}{pc}{\splugin f {i_1 \dots i_{n}}}{\vplugin{\Delta''}}{pc \sqcup \ell}}%\\[1.5ex]\displaybreak[0]
\end{gather*}
Finally, names defined in modules and plugins can be accessed through their environment:
\begin{gather*}
  \prftree[r]{[FieldAccess]}
  {\bstep{\Delta}{pc}{e}{\textit{m}~{\Delta'}}{\ell}}
  {\Delta'(x) = \langle v, \ell' \rangle}
  {\textit{m} \in \left\{ \mathrm{mod}, \mathrm{tmod}, \mathrm{plug} \right\}}
  {\bstep{\Delta}{pc}{e.x}{v}{pc \sqcup \ell \sqcup \ell'}}\\[4ex]\displaybreak[1]
  %
  % \prftree[r]{[FieldAccessNoSecret]}
  % {\bstep{\Delta}{pc}{e}{\textit{m}~{\Delta'}}{\ell}}
  % {\Delta'(x) = \langle \vnosecret v, \ell' \rangle}
  % {\textit{m} \in \left\{ \mathrm{mod}, \mathrm{tmod}, \mathrm{plug} \right\}}
  % {\bstep{\Delta}{pc}{e.x}{\text{apply-nosecret}(v)}{pc \sqcup \ell \sqcup \ell'}}\\[4ex]\displaybreak[1]
  %
\end{gather*}

We provide operators for declassifying and endorsing values as well as the control flow label (\(pc\)). Those operators can only be used inside trusted modules. Furthermore declassification of a \(\mathrm{secret}^{p}\) value can only be performed inside the plugin \(p\) or the main module \(0\).
\begin{gather*}
    \prftree[r]{[Declassify]}
    {\prfStackPremises
      {{\bstep{\Delta}{pc}{e}{v}{\langle \ell_{C}, \ell_{I} \rangle}}
        \quad {\Delta(\mathrm{@trusted}) = \true}}
      {\ell_{C} = \mathrm{secret}^{p} \Rightarrow \Delta(\mathrm{@plugin}) \in \left\{ 0, p \right\}}}
    {\bstepp{\Delta}{pc}{\sdeclassify e}{v}{\mathrm{public}}{\ell_{I}}}\\[1.5ex]\displaybreak[0]
    % 
    \prftree[r]{[Endorse]}
    {\bstep{\Delta}{pc}{e}{v}{\langle \ell_{C}, \ell_{I} \rangle}}
    {\Delta(\mathrm{@trusted}) = \true}
    {\bstepp{\Delta}{pc}{\sendorse e}{v}{\ell_{C}}{\mathrm{untainted}}}\\[1.5ex]\displaybreak[0]
    % 
    \prftree[r]{[DeclassifyPC]}
    {\prfStackPremises
      {\mathit{pc}_{C} = \mathrm{secret}^{p} \Rightarrow \Delta(\mathrm{@plugin}) \in \left\{ 0, p \right\}
        \quad {\Delta(\mathrm{@trusted}) = \true}}
      {{\bstepp{\Delta}{\langle \mathrm{public}, \mathit{pc}_{I} \rangle}{e}{v}{\ell_{C}}{\ell_{I}}}
      }}
    {\bstepp{\Delta}{\langle \mathit{pc}_{C}, \mathit{pc}_{I} \rangle}{\sdeclassifypc e}{v}{\ell_{C}}{\mathit{pc}_{I} \sqcup \ell_{I}}}\\[1.5ex]\displaybreak[0]
    % 
    \prftree[r]{[EndorsePC]}
    {\Delta(\mathrm{@trusted}) = \true}
    {\bstepp{\Delta}{\langle \mathit{pc}_{C}, \mathrm{untainted} \rangle}{e}{v}{\ell_{C}}{\ell_{I}}}
    {\bstepp{\Delta}{\langle \mathit{pc}_{C}, \mathit{pc}_{I} \rangle}{\sendorsepc e}{v}{\mathit{pc}_{C} \sqcup \ell_{C}}{\ell_{I}}}\\[3ex]\displaybreak[1]
\end{gather*}

\texttt{has\_attr} can be used to check whether a value has a certain attribute. \(\sassert e\) halts the program if \(e\) evaluates to false. \texttt{die} has no rules, thus it always halts the program.
\begin{gather*}
  \prftree[r]{[HasAttr]}
  {\prfStackPremises
  {\bstep{\Delta}{pc}{e}{v}{\langle \ell_{C}, \ell_{I} \rangle}}
  {b \triangleq
    \begin{aligned}[t]
      &(attr = \texttt{public} \wedge \ell_{C} = \mathrm{public}) \vee (attr = \texttt{secret} \wedge \exists p.\;  \ell_{C} = \mathrm{secret}^{p}) \\
      {}\vee{}&
      (attr = \texttt{untainted} \wedge \ell_{I} = \mathrm{untainted}) \vee (attr = \texttt{tainted} \wedge \ell_{I} = \mathrm{tainted})
          \end{aligned}}}
  {\bstep{\Delta}{pc}{\spredicate {attr} e}{b}{pc \sqcup \langle \ell_{C}, \ell_{I} \rangle}}\\[4ex]\displaybreak[1]
  %
  \prftree[r]{[Assert]}
  {\bstep{\Delta}{pc}{e}{\true}{\ell}}
  {\bstep{\Delta}{pc}{\sassert e}{\true}{pc \sqcup \ell}}\\[4ex]\displaybreak[1]
\end{gather*}
To avoid information leak, it would be ideal to prevent usage of \texttt{assert} and \texttt{die} in secret contexts, since program termination is a covert information channel. However, we chose not to since they can always be implemented as functions:
\begin{verbatim}
    let my_assert guard =
        if guard then
            true
        else
            # crash exploiting a security violation
            let public x =
                (let secret x = 1 in x)
            in []
\end{verbatim}
and we have no way to prevent program termination in secret contexts in all cases.

Finally, we have operators for simple input and output:
\begin{gather*}
  \prftree[r]{[Print]}
  {\bstep{\Delta}{pc}{e}{v}{\ell}}
  {pc \sqcup \ell = \langle \mathrm{public}, \ell_{I} \rangle}
  {\bstep{\Delta}{pc}{\sprint e}{v}{pc \sqcup \ell}}\\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[Get]}
  {v \triangleq \text{user input}}
  {\bstep{\Delta}{pc}{\sget}{v}{pc \sqcup \langle \mathrm{public},\mathrm{tainted} \rangle}}\\[4ex]\displaybreak[1]
\end{gather*}

The initial environment contains the bindings \(\mathrm{plugin} \mapsto 0, \mathrm{trusted} \mapsto \false\).




\section{Effect handlers}

We initially decided to implement effect handlers for the language\footnote{Realistically, could we make a language and not put algebraic effects in it?} and redefine security exceptions as operations. This would make for a more flexible language, where the program does not necessarily crash when a security violation happens. For example, one could implement a password manager that returns the password in secret contexts, but when an exception is raised on accessing the password from a public context, the manager would return an obfuscated version of the password and resume the execution. An effect system would also make for some interesting considerations regarding control and information flow, for example on whether we need to consider the invocation itself of operations a covert channel, as it might be dependent on some data inputted by an attacker.

Unfortunately, it was not possible to implement handlers during this timeframe. Nevertheless, here are some prototype rules for basic handler definition, operation raising and handling, and to build continuations for simple constructs such as binary operations.

\begin{gather*}
  \prftree[r]{[Do]}
  {\forall i \in [1,n].\; \bste{\Delta}{pc}{e_{i}}{\valpair v_{i}}}
  {y~\text{fresh}}
  {\bste{\Delta}{pc}{\sdo{op}{e_1~\dots~e_{n}}}{\langle op, \vlam \Delta y y, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc \rangle}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[HandleRet]}
  {\bste{\Delta}{pc}{e}{\valpair v}}
  {(\texttt{return}~x=e_{\mathrm{ret}}) \in h}
  {\bste{\ext \Delta x {\valpair v}}{pc}{e_{\mathrm{ret}}}{\nu}}
  {\bste{\Delta}{pc}{\shandle h e}{\nu}} \\[1.5ex]\displaybreak[0]
  %
  % \prftree[r]{[HandleRetRaise]}
  % {\prfStackPremises
  % {{\bste{\Delta}{pc}{e}{\valpair v}} \quad {(\texttt{return}~x=e_{\mathrm{ret}}) \in h}}
  % {\bste{\ext \Delta x {\valpair v}}{pc}{e_{\mathrm{ret}}}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}}
  % {\bste{\Delta}{pc}{\shandle h e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc'\rangle}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[HandleRaise]}
    {\bste{\Delta}{pc}{e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
    {(op~x_1~\dots~x_{n}~k=e_{\mathrm{op}}) \notin h}
    {y~\text{fresh}}
  {\bste{\Delta}{pc}{\shandle h e}{\langle op, \vlam \Delta y {\shandle h {c~y}}, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}} \\[3ex]\displaybreak[0]
  %
  \prftree[r]{[HandleOp]}
  {\prfStackPremises
    {\bste{\Delta}{pc}{e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
    {(op~x_1~\dots~x_{n}~k=e_{\mathrm{op}}) \in h}
    {{c' = \vlam \Delta y {\shandle h {c~y}}} \quad {y~\text{fresh}}}
    {\bste{\Delta[x_1 \mapsto \valpair v_1,\dots,x_{n} \mapsto \valpair v_{n}, k \mapsto \langle c', pc' \rangle]}{pc'}{e_{\mathrm{op}}}{\nu}}}
  {\bste{\Delta}{pc}{\shandle h e}{\nu}} \\[3ex]\displaybreak[1]
  %
  % \prftree[r]{[HandleOpRaise]}
  % {\prfStackPremises
  %   {\bste{\Delta}{pc}{e}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
  %   {(op~x_1~\dots~x_{n}~k=e_{\mathrm{op}}) \in h}
  %   {{c' = \vlam \Delta y {\shandle h {c~y}}} \quad {y~\text{fresh}}}
  %   {\bste{\Delta[x_1 \mapsto \valpair v_1,\dots,x_{n} \mapsto \valpair v_{n}, k \mapsto \langle c', pc' \rangle]}{pc'}{e_{\mathrm{op}}}{\langle op', c', \langle \valpair v_1',\dots,\valpair v_{n}' \rangle, pc'' \rangle}}}
  % {\bste{\Delta}{pc}{\shandle h e}{{\langle op', c', \langle \valpair v_1',\dots,\valpair v_{n}' \rangle, pc'' \rangle}}} \\[4ex]\displaybreak[1]
  %
  \prftree[r]{[BopRaiseL]}
  {\bste{\Delta}{pc}{e_1}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
  {y~\text{fresh}}
  {\bste{\Delta}{pc}{e_1~\mathit{bop}~e_2}{\langle op, \vlam \Delta y {(c~y)~\mathit{bop}~e_2, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc'\rangle}}} \\[1.5ex]\displaybreak[0]
  %
  \prftree[r]{[BopRaiseR]}
  {\bste{\Delta}{pc}{e_1}{\valpair v}}
  {\bste{\Delta}{pc}{e_2}{\langle op, c, \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc' \rangle}}
  {x,y~\text{fresh}}
  {\bste{\Delta}{pc}{e_1~\mathit{bop}~e_2}{\langle op, \vlam {\ext \Delta x {\valpair v}} y {x~\mathit{bop}~(c~y), \langle \valpair v_1,\dots,\valpair v_{n} \rangle, pc'\rangle}}} \\[1.5ex]\displaybreak[0]
\end{gather*}

% \begin{align*}
%   \text{check-type}(v, \tau) =
%   \begin{cases}
%     \true & \begin{aligned}[t]
%       (\tau &=\stint \wedge v \in \mathrm{Int}) \\
%       {}\vee (\tau &= \ststring \wedge v \in \mathrm{Str}) \\
%       {}\vee (\tau &= \stbool \wedge v \in \mathrm{Bool}) \\
%       {}\vee (\tau &= \stuple{\tau_1\scomma \dots \scomma \tau_n} \wedge v = \stuple{v_1\scomma \dots \scomma v_n} \\
%       &\wedge \bigwedge_{i=1}^{n} \text{check-type}(v_{i}, \tau_{i}))
%     \end{aligned} \\
%     \false & \text{otherwise} % \tau = \tau_1 \to \tau_2 \\
%     % \text{undefined} & \text{otherwise}
%   \end{cases}
% \end{align*}


% \begin{align*}
%   &\text{apply-nosecret}(\langle v, \overbrace{\langle \mathrm{public}, \ell_{I} \rangle}^{\ell}\rangle) =
%   \begin{dcases}
%     \langle v, \ell \rangle & v \in \mathrm{Int} \cup \mathrm{Str} \cup \mathrm{Bool} \\
%     \langle \vnosecret v, \ell \rangle & v \in \mathrm{Fun} \cup \mathrm{Mod} \\
%     \begin{aligned}
%       \langle [&\text{apply-nosecret}(\valpair{v}_1),
%       \dots, \\
%       &\text{apply-nosecret}(\valpair{v}_n)
%       ], \ell \rangle
%     \end{aligned}
%     & v = [\valpair{v}_1, \dots , \valpair{v}_n] \\
%     \langle \text{apply-nosecret}(v') : \tau, \ell \rangle & v = v' : \tau \\
%     {\color{red}\langle v, \ell \rangle} & v = \vnosecret v'
%   \end{dcases}
%   \\[2ex]
%   &\text{apply-nosecret}(\langle v, \langle \mathrm{secret}, \ell_{I} \rangle\rangle) = \mathrm{undefined} 
% \end{align*}



% \begin{align*}
%   \mathrm{bind}(b, \langle v, \ell \rangle) =
%   \begin{dcases}
%     \ext{\varnothing}{b}{\langle v, \ell \rangle} & b \in \mathrm{Ide} \\[1.5ex]
%     \begin{aligned}
%       \varnothing
%       &[\mathrm{bind}(b_1, \langle v_1, \ell_1 \sqcup \ell \rangle)] \\ &\cdots
%       [\mathrm{bind}(b_n, \langle v_n, \ell_n \sqcup \ell \rangle)]
%     \end{aligned}
%     & \begin{aligned}
%       b &= \stuple{b_1\scomma\dots\scomma b_{n}} \\
%       {}\wedge v &= [\langle v_1, \ell_1 \rangle,\dots,\langle v_1, \ell_1 \rangle]
%       \end{aligned}
%   \end{dcases}
% \end{align*}





% TODO per handler:
% pc in e2 BopRaiseL
% join pc pc' in HandleOp?


% TODO scartati che forse non dovevano essere scartati
% fix* si pu√≤ togliere join?
% dire cosa sono c, k, valpair, \(\nu\), \(a\) (attributi)

\section{Executing the interpreter}
These instructions assume that \texttt{opam} is installed and that \texttt{make} is available on the machine.
\begin{enumerate}
  \item Clone the git repository at \url{git@github.com:Alex23087/Scaml2.git}
  \item Go into the \texttt{src} folder, and run \texttt{make setup} to install the required OCaml packages
  \item Run \texttt{make test-interpreter} to run the unit tests
  \item Run \texttt{make exec file=\emph{filename}} to execute a \scaml program saved in \emph{filename}.
  \item In the \texttt{example} folder, run the script \texttt{run.sh} to run an example program.
\end{enumerate}



\end{document}
